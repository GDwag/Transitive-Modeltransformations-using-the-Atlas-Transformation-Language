-- @path Palladio=http://palladiosimulator.org/PalladioComponentModel/5.2
-- @path UML=http://www.eclipse.org/uml2/5.0.0/UML

module Palladio2UML;
-- Module Template
create OUT: UML from IN: Palladio;

rule Repository2Model {
	from R : Palladio!Repository
	to M : UML!Model (
		name <- 'MediaStoreUML',
		nestedPackage <- thisModule.Repostiory2DatatypesPackage(R),
		nestedPackage <- thisModule.Repostiory2ContractsPackage(R),
		nestedPackage <- thisModule.Repostiory2DefaultPackage(R)
	)
}

--Package Stuff
unique lazy rule Repostiory2DefaultPackage {
	from R : Palladio!Repository
	to P : UML!Package ( --Components
		name <- R.entityName,
		nestedPackage <- R.components__Repository
	)
}

unique lazy rule Repostiory2ContractsPackage {
	from R : Palladio!Repository
	to P2 : UML!Package ( --Interfaces		--scheint nicht so zu funktionieren, andere packages werden nicht angelegt
		name <- R.entityName + 'Contracts',
		packagedElement <- R.interfaces__Repository->collect(e | thisModule.OperationInterface2Interface(e))
	)
}

unique lazy rule Repostiory2DatatypesPackage {
	from R : Palladio!Repository
	to P3 : UML!Package ( --Datatypes
		name <- R.entityName + 'Datatypes',
		packagedElement <- R.dataTypes__Repository
	)
}
--Package Stuff end

--Interface Stuff
unique lazy rule OperationInterface2Interface { --WARNING - making this *unique* was necessary for some later *references*, but making it *unique* required making it *lazy*, and making it *lazy* mean i need to *manually* use it for every interface
	from PI : Palladio!Interface
	to UI : UML!Interface (
		name <- PI.entityName,
		protocol <- PI.protocols__Interface,
		ownedOperation <- PI.signatures__OperationInterface->collect(e | thisModule.Signature2Operation(e))
	)
}


	--Signature-Stuff
unique lazy rule Signature2Operation {
	from S : Palladio!Signature
	to O : UML!Operation (
		name <- S.entityName,
		type <- S.returnType__OperationSignature,
		ownedTemplateSignature <- thisModule.Signature2TemplateSignature(S) --owned correct? also non-containment alternative available
	)
}

--unique lazy rule Signature2TemplateParameter {
--	from S : Palladio!Signature
--	to T : UML!OperationTemplateParameter (
--		signature <- thisModule.Signature2TemplateSignature(S)
--	)
--}

unique lazy rule Signature2TemplateSignature {
	from S :  Palladio!Signature
	to T : UML!TemplateSignature (
		ownedParameter <- S.parameters__OperationSignature->collect(e | thisModule.Parameter2TemplateParameter(e)) --owned correct? also non-containment alternative available
	)
}

unique lazy rule Parameter2TemplateParameter {
	from P : Palladio!Parameter
	to T : UML!TemplateParameter (
		--TODO how to get from PCM-Parameter-Type to a type definition in UML?
	)
}
	--Signature Stuff end
--Interface Stuff end

rule Protocol2ProtocalStateMachine { --WARNING no change in model - why?
	from PP : Palladio!Protocol
	to UP: UML!ProtocalStateMachine ( --Palladio Protocol only has EString ID, which UML doesnt
	)
}

--Component Stuff
rule BasicComponent2Package {
	from B : Palladio!BasicComponent
	to P : UML!Package (
		nestingPackage <- thisModule.Repostiory2DefaultPackage(B.repository__RepositoryComponent),
		name <- B.entityName,
		packagedElement <- thisModule.BasicComponent2Class(B)
	)	
}

unique lazy rule BasicComponent2Class {
	from B : Palladio!BasicComponent
	to C : UML!Class (
		name <- B.entityName + 'Impl',
		interfaceRealization <- B.providedRoles_InterfaceProvidingEntity, --NOT extension - extensions refer to stereotypes
		ownedAttribute <- B.requiredRoles_InterfaceRequiringEntity,
		ownedOperation <- B.requiredRoles_InterfaceRequiringEntity->collect(e | thisModule.RequiredRole2Getter(e)),
		ownedOperation <- B.requiredRoles_InterfaceRequiringEntity->collect(e | thisModule.RequiredRole2Setter(e))
	)
}

rule RequiredRole2Attribute {
	from R : Palladio!OperationRequiredRole
	to M : UML!Property (
   		name <- R.entityName,
		type <- thisModule.OperationInterface2Interface(R.requiredInterface__OperationRequiredRole)--,
		--class <- thisModule.BasicComponent2Class(R.requiringEntity_RequiredRole) --"feature 'class' is not changeable"
		-- + Parameter in Konstruktor -- ist eigener typ (?)
	)
}

lazy rule RequiredRole2Getter {
	from R : Palladio!OperationRequiredRole
	to M : UML!Operation (
   		name <- 'get' + R.entityName,
		class <- thisModule.BasicComponent2Class(R.requiringEntity_RequiredRole),
		type <-  thisModule.OperationInterface2Interface(R.requiredInterface__OperationRequiredRole)--, --this is a return type, though it is a "parameter" in the model
		--ownedTemplateSignature <- R.requiredInterface__OperationRequiredRole.signatures__OperationInterface->collect(e | thisModule.Signature2TemplateSignature(e)) --not good, because causes signatures to be stored in Operations instead of Interfaces. Workarround?
	)
}

lazy rule RequiredRole2Setter {
	from R : Palladio!OperationRequiredRole
	to --TS : UML!TemplateSignature(
		--template <- R.requiredInterface__OperationRequiredRole,
		--parameter <- TP
	--),
	--TP : UML!OperationTemplateParameter (
		--signature <- TS,
		--parameteredElement <- M
	--),
	M : UML!Operation (
   		name <- 'set' + R.entityName,
		class <- thisModule.BasicComponent2Class(R.requiringEntity_RequiredRole)--,
		--ownedTemplateSignature <- R.requiredInterface__OperationRequiredRole.signatures__OperationInterface->collect(e | thisModule.Signature2TemplateSignature(e)) --not good, because causes signatures to be stored in Operations instead of Interfaces. Workarround?
		--type <- Void --return type: how to set to void?
		--owningTemplateParameter <- TP
	)
}

rule ProvidedRole2InterfaceRealization {
	from P : Palladio!OperationProvidedRole
	to E : UML!InterfaceRealization(
		name <- P.entityName,
		implementingClassifier <- thisModule.BasicComponent2Class(P.providingEntity_ProvidedRole)
	)
}
--Class Stuff end

--CompositeDataType und CompositeComponent nicht verwandt? gewollt?!
rule CompositeDataType2Class { --? wie getter und setter einrichten? TODO
	from D : Palladio!CompositeDataType
	to C : UML!Class (
		nestedClassifier <- D.innerDeclaration_CompositeDataType
	)	
}

rule InnerDeclaration2Class { --? kaum inhalte in inner declaration, wie soll ich daraus eine sinnvolle klasse machen? TODO
	from I : Palladio!InnerDeclaration
	to C : UML!Class (
		name <- I.entityName
	)
}

rule CollectionDataType2Class {
	from D : Palladio!CollectionDataType
	to C : UML!Class (
		
	)	
	
}