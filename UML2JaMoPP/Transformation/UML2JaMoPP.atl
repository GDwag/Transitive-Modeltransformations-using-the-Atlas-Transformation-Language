-- @path UML=http://www.eclipse.org/uml2/5.0.0/UML
-- @path JaMoPP=http://www.emftext.org/java/

module UML2JaMoPP;
-- Module Template
create OUT: JaMoPP from IN: UML; 

helper context UML!Model def: setupPackages() : String =
	self.nestedPackage->collect(e | thisModule.Package2Package(e).name)->sum();

rule Model2EmptyModel {
	from M : UML!Model
	to E : JaMoPP!EmptyModel (
		name <-	M->setupPackages(), --dirty Hack to force hierarchical creation of Packages
		name <- M.name
	)
}

unique lazy rule Package2Package {
	from P1 : UML!Package
	to P2 : JaMoPP!Package (
		name <- P1.name,
		--compilationUnits <- P1.nestedPackage->collect(e | thisModule.Package2CompilationUnit(e)),
		compilationUnits <- if P1.nestedPackage.isEmpty() then thisModule.Package2CompilationUnit(P1) else P1.nestedPackage->collect(e | thisModule.Package2CompilationUnit(e)) endif
	)
}

unique lazy rule Package2CompilationUnit {
	from P : UML!Package
	to C : JaMoPP!CompilationUnit (
		name <- P.name,
		classifiers <- P.packagedElement-- ->collect(e | 
			--if e->oclIsTypeOf(UML!Interface) then thisModule.Interface2Interface(e) 
			--else if e->oclIsTypeOf(UML!DataType) then thisModule.DataType2Class 
			--else thisModule.Class2Class(e) endif endif)
			--without this lazy stuff, Behaviors are Translated to Classes outside of any context; with it, there are errors
	)
}

--unique lazy 
rule Interface2Interface {
	from I1 : UML!Interface
	to I2 : JaMoPP!Interface (
		name <- I1.name,
		members <- I1.ownedOperation->collect (e | thisModule.Operation2ClassMethod(e))
		--typeParameters <- Set {O.signatures__OperationInterface}
	)
}

--rule Signature2TypeParameter {
--	from S :  UML!Parameter
--	to T :  JaMoPP!TypeParameter (
--		name <- S.entityName--,
--		--extendTypes <- Set {S.parameters__OperationSignature} --from Palladio2JaMoPP
--	)
--}

--unique lazy 
rule Class2Class {
	from C1: UML!Class
	to C2 : JaMoPP!Class (
		name <- C1.name,
		implements <- C1.interfaceRealization,
		members <- C1.ownedAttribute->collect(e | thisModule.Property2Field(e)),
		members <- C1.ownedBehavior->collect (e | thisModule.Behavior2Constructor(e)),
		members <- C1.ownedOperation->collect (e | thisModule.Operation2ClassMethod(e)),
		members <- C1.nestedClassifier --From InnerDeclaration of Palladios CompositeDataType
	)
}

--unique lazy 
rule DataType2Class{
	from C1: UML!DataType
	to C2 : JaMoPP!Class (
		name <- C1.name, --all below would exist, but is unnecessary because it doesn't exist in Palladio
		members <- C1.ownedAttribute->collect(e | thisModule.Property2Field(e)),
		members <- C1.ownedOperation->collect(e | thisModule.Operation2ClassMethod(e))
	)
}

unique lazy rule Property2Field {
	from P : UML!Property
	to F : JaMoPP!Field (
   		name <- P.name,
		typeReference <- thisModule.Interface2ClassifierReference(P.type)
		--type <- P.type
		-- + type
	)
}

--WARNING TODO Behavior isKindOf(UML!Class), which is why they are created as classes outside of any context.
lazy rule Behavior2Constructor { --lazy because "Trying to register several rules as default for element org.eclipse.uml2.uml.internal.impl.ActivityImpl" (because it's a class)
	from B : UML!Behavior
	to C : JaMoPP!Constructor (
		name <- B.name + 'Constructor',
		parameters <- B.ownedParameter->collect(e | thisModule.Parameter2Parameter(e))--,
		--typeParameters <- B.ownedParameter
	)
}

unique lazy rule Parameter2Parameter {
	from P1 : UML!Parameter
	to P2 : JaMoPP!OrdinaryParameter (
		name <- P1.name,
		typeReference <- thisModule.Interface2ClassifierReference(P1.type)
	)
}

unique lazy rule Interface2ClassifierReference {
	from I : UML!Interface
	to R : JaMoPP!ClassifierReference (
		target <- I
	)
}

unique lazy rule Operation2ClassMethod { --if not "unique lazy", there seems to be some kind of "race condition", causing these to be created outside of their intended scope after doing seemingly unrelated changes
	from O : UML!Operation
	to M : JaMoPP!ClassMethod (
		name <- O.name
	)
	
}

rule InterfaceRealization2ClassifierReference {
	from E : UML!InterfaceRealization
	to C : JaMoPP!ClassifierReference(
	)
}

--rule Signature2TypeParameter {
--	from S :  Palladio!Signature
--	to T :  JaMoPP!TypeParameter (
--		name <- S.entityName,
--		extendTypes <- Set {S.parameters__OperationSignature}
--	)
--}
