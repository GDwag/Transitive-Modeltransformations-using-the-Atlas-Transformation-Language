-- @path UML=http://www.eclipse.org/uml2/5.0.0/UML
-- @path JaMoPP=http://www.emftext.org/java/

module UML2JaMoPP;
-- Module Template
create OUT: JaMoPP from IN: UML; 

helper context UML!Package def: setupPackages() : String =
	self.nestedPackage->collect(e | thisModule.Package2Package(e).name)->sum();

--Package foo
rule Model2Package {
	from M : UML!Model
	to E : JaMoPP!Package (
		name <-	M->setupPackages(), --dirty Hack to force creation of Packages with lazy rule (otherwise setting up compilation units is hindered by packages being of kind UML!PackageableElements themselves)
		name <- M.name
	)
}

unique lazy rule Package2Package {
	from P1 : UML!Package
	to P2 : JaMoPP!Package (
		name <- P1->setupPackages(), --dirty Hack to force creation of Packages with lazy rule (otherwise setting up compilation units is hindered by packages being of kind UML!PackageableElements themselves)
		name <- if P1.nestingPackage->oclIsUndefined() then P1.name 
			else if P1.nestingPackage->oclIsTypeOf(UML!Model) then P1.nestingPackage.name + '.' + P1.name
			else P1.nestingPackage.nestingPackage.name + '.' + P1.nestingPackage.name + '.' + P1.name endif endif, --WARNING TODO - helper function for any amount of packages above?
		--compilationUnits <- P1.packagedElement --would be too easy without the need of lazy rules - Class-CUs are created outside of Repo-Package for some reason
		compilationUnits <- P1.packagedElement->collect(e | 
			if e.oclIsTypeOf(UML!Interface) then thisModule.Interface2CompilationUnit(e)
			else if e.oclIsTypeOf(UML!Class) then thisModule.Class2CompilationUnit(e)
			--else if e.oclIsTypeOf(UML!DataType) then thisModule.DataType2CompilationUnit(e) --Palladio DataTypes are Transformed to UML Classes
			else Sequence {} endif endif --endif
		)
	)
}
--Package foo end

--Interface foo
unique lazy rule Interface2CompilationUnit {
	from I : UML!Interface
	to C : JaMoPP!CompilationUnit (
		name <- I.name,
		classifiers <- thisModule.Interface2Interface(I)
	)
}

unique lazy rule Interface2Interface {
	from I1 : UML!Interface
	to I2 : JaMoPP!Interface (
		name <- I1.name,
		members <- I1.ownedOperation->collect (e | thisModule.Operation2ClassMethod(e))
		--typeParameters <- Set {O.signatures__OperationInterface}
	)
}

lazy rule Interface2ClassifierReference {
	from I : UML!Interface
	to R : JaMoPP!ClassifierReference (
		target <- thisModule.Interface2Interface(I)
	)
}

lazy rule InterfaceRealization2ClassifierReference {
	from I : UML!InterfaceRealization
	to C : JaMoPP!ClassifierReference(
		target <- thisModule.Class2Class(I.implementingClassifier)
	)
}
--Interface foo end

--Class foo
unique lazy rule Class2CompilationUnit {
	from CL : UML!Class
	to CU : JaMoPP!CompilationUnit (
		name <- CL.name,
		classifiers <- thisModule.Class2Class(CL)
	)
}

unique lazy rule Class2Class {
	from C1: UML!Class
	to C2 : JaMoPP!Class (
		name <- C1.name,
		implements <- C1.interfaceRealization->collect(e | thisModule.InterfaceRealization2ClassifierReference(e)),
		members <- C1.ownedAttribute->collect(e | thisModule.Property2Field(e)),
		members <- C1.ownedOperation->collect (e | if e.name = C1.name then thisModule.Operation2Constructor(e) else thisModule.Operation2ClassMethod(e) endif),
		members <- C1.nestedClassifier->collect(e | thisModule.Class2Class(e)) --From InnerDeclaration of Palladios CompositeDataType
	)
}

	--Class Members foo
unique lazy rule Property2Field {
	from P : UML!Property
	to F : JaMoPP!Field (
   		name <- P.name,
		--thaught this would solve the issue of weird CompositeDataTypeInterfaces beeing created - didn't
		--typeReference <- if P.type.oclIsTypeOf(UML!Interface) then thisModule.Interface2ClassifierReference(P.type) else thisModule.Class2ClassifierReference(P.type) endif
		typeReference <- if P.type.oclIsTypeOf(UML!Class) then thisModule.Class2ClassifierReference(P.type) else thisModule.Interface2ClassifierReference(P.type) endif
		--typeReference <- thisModule.Interface2ClassifierReference(P.type)
	)
}
	
--thaught this would solve the issue of weird CompositeDataTypeInterfaces beeing created - didn't
lazy rule Class2ClassifierReference {
	from C : UML!Class
	to R : JaMoPP!ClassifierReference (
		target <- thisModule.Class2Class(C)
	)
}

lazy rule Operation2Constructor { --lazy because "Trying to register several rules as default for element org.eclipse.uml2.uml.internal.impl.ActivityImpl" (because it's a class)
	from B : UML!Operation
	to C : JaMoPP!Constructor (
		name <- B.name,
		parameters <- B.ownedParameter->collect(e | thisModule.Parameter2Parameter(e))--,
	)
}

unique lazy rule Operation2ClassMethod { --if not "unique lazy", there seems to be some kind of "race condition", causing these to be created outside of their intended scope after doing seemingly unrelated changes
	from O : UML!Operation
	to M : JaMoPP!ClassMethod (
		name <- O.name,
		parameters <- O.ownedParameter->collect(e | if e.direction = #return then Set{} else thisModule.Parameter2Parameter(e) endif),
		typeReference <- O.ownedParameter->collect(e | if e.direction = #return then thisModule.Parameter2ReturnType(e) else Set{} endif)
	)
}

unique lazy rule Parameter2Parameter {
	from P1 : UML!Parameter
	to P2 : JaMoPP!OrdinaryParameter (
		name <- P1.name,
		typeReference <- thisModule.Interface2ClassifierReference(P1.type)
	)
}

unique lazy rule Parameter2ReturnType {
	from P : UML!Parameter
	to T : JaMoPP!ClassifierReference (
		target <- thisModule.Interface2Interface(P.type)
	)
}
	--Class Members foo end
--Class foo end