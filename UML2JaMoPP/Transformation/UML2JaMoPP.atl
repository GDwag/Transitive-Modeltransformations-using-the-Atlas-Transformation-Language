-- @path UML=http://www.eclipse.org/uml2/5.0.0/UML
-- @path JaMoPP=http://www.emftext.org/java/

module UML2JaMoPP;
-- Module Template
create OUT: JaMoPP from IN: UML; 

helper context UML!Model def: setupPackages() : String =
	self.nestedPackage->collect(e | thisModule.Package2Package(e).name)->sum();

rule Model2Package {
	from M : UML!Model
	to E : JaMoPP!Package (
		name <-	M->setupPackages(), --dirty Hack to force creation of Packages with lazy rule (otherwise setting up compilation units is hindered by packages being of kind UML!PackageableElements themselves)
		name <- M.name
	)
}

unique lazy rule Package2Package {
	from P1 : UML!Package
	to P2 : JaMoPP!Package (
		name <- P1.name,
		compilationUnits <- P1.packagedElement --if P1.nestedPackage.isEmpty() then thisModule.Package2CompilationUnit(P1) else P1.nestedPackage->collect(e | thisModule.Package2CompilationUnit(e)) endif
	)
}

--Interface foo
rule Interface2CompilationUnit {
	from I : UML!Interface
	to C : JaMoPP!CompilationUnit (
		name <- I.name,
		classifiers <- thisModule.Interface2Interface(I)
	)
}

unique lazy rule Interface2Interface {
	from I1 : UML!Interface
	to I2 : JaMoPP!Interface (
		name <- I1.name,
		members <- I1.ownedOperation->collect (e | thisModule.Operation2ClassMethod(e))
		--typeParameters <- Set {O.signatures__OperationInterface}
	)
}
--Interface foo end

--Class foo
rule Class2CompilationUnit {
	from CL : UML!Class
	to CU : JaMoPP!CompilationUnit (
		name <- CL.name,
		classifiers <- thisModule.Class2Class(CL)
	)
}

unique lazy rule Class2Class {
	from C1: UML!Class
	to C2 : JaMoPP!Class (
		name <- C1.name,
		implements <- C1.interfaceRealization,
		members <- C1.ownedAttribute->collect(e | thisModule.Property2Field(e)),
		members <- C1.ownedBehavior->collect (e | thisModule.Behavior2Constructor(e)),
		members <- C1.ownedOperation->collect (e | thisModule.Operation2ClassMethod(e)),
		members <- C1.nestedClassifier->collect(e | thisModule.Class2Class(e)) --From InnerDeclaration of Palladios CompositeDataType
	)
}
--Class foo end

rule DataType2CompilationUnit {
	from D : UML!DataType
	to C : JaMoPP!CompilationUnit (
		name <- D.name,
		classifiers <- thisModule.DataType2Class(D)
	)
}

unique lazy rule DataType2Class {
	from C1: UML!DataType
	to C2 : JaMoPP!Class (
		name <- C1.name, --all below would exist, but is unnecessary because it doesn't exist in Palladio
		members <- C1.ownedAttribute->collect(e | thisModule.Property2Field(e)),
		members <- C1.ownedOperation->collect(e | thisModule.Operation2ClassMethod(e))
	)
}

unique lazy rule Property2Field {
	from P : UML!Property
	to F : JaMoPP!Field (
   		name <- P.name,
		typeReference <- thisModule.Interface2ClassifierReference(P.type)
		--type <- P.type
		-- + type
	)
}

lazy rule Operation2Constructor { --lazy because "Trying to register several rules as default for element org.eclipse.uml2.uml.internal.impl.ActivityImpl" (because it's a class)
	from B : UML!Operation
	to C : JaMoPP!Constructor (
		name <- B.name + 'Constructor',
		parameters <- B.ownedParameter->collect(e | thisModule.Parameter2Parameter(e))--,
	)
}

unique lazy rule Parameter2Parameter {
	from P1 : UML!Parameter
	to P2 : JaMoPP!OrdinaryParameter (
		name <- P1.name,
		typeReference <- thisModule.Interface2ClassifierReference(P1.type)
	)
}

unique lazy rule Interface2ClassifierReference {
	from I : UML!Interface
	to R : JaMoPP!ClassifierReference (
		target <- thisModule.Interface2Interface(I)
	)
}

unique lazy rule Operation2ClassMethod { --if not "unique lazy", there seems to be some kind of "race condition", causing these to be created outside of their intended scope after doing seemingly unrelated changes
	from O : UML!Operation
	to M : JaMoPP!ClassMethod (
		name <- O.name,
		parameters <- O.ownedParameter->collect(e | thisModule.Parameter2Parameter(e))
	)
}

rule InterfaceRealization2ClassifierReference {
	from E : UML!InterfaceRealization
	to C : JaMoPP!ClassifierReference(
	)
}