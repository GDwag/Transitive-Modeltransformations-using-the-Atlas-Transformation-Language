-- @path Palladio=http://palladiosimulator.org/PalladioComponentModel/5.2
-- @path JaMoPP=http://www.emftext.org/java/

module Palladio2JaMoPP;
-- Module Template
create OUT : JaMoPP from IN: Palladio;

rule Repostiory2Package {
	from R : Palladio!Repository
	to PI : JaMoPP!Package (
		name <- R.entityName + 'Contracts',
		compilationUnits <- R.interfaces__Repository
		--imports <- R.components__Repository --how to create sub-Packages?!
	),
	PC : JaMoPP!Package (
		name <- R.entityName--,
		--compilationUnits <- R.components__Repository --each their own package instead - seperate, but with a corresponding name
	),
	PD : JaMoPP!Package (
		name <- R.entityName + 'DataTypes',
		compilationUnits <- R.dataTypes__Repository
	)
}



--anything better than class? TypeParameter doesn't work, as it is no concrete classifier
unique lazy rule DataType2Class {
	from D : Palladio!DataType
	to T : JaMoPP!Class (
		name <- D.entityName
		--no transformable content - Palladio DataType doesn't inherit from anything and has its repository as only attribute
	)
}

--WARNING CompilationUnit instead of Package ok? JaMoPP doesn't know subpackages...
--unique lazy rule BasicComponent2Package {
--	from B : Palladio!BasicComponent
--	to P : JaMoPP!Package(
--		name <- 'Repo/' + B.entityName,
--		compilationUnits <- thisModule.BasicComponent2CompilationUnit(B)
--	)
--}

--Interface Foo
unique lazy rule OperationInterface2CompilationUnit {
	from B : Palladio!OperationInterface
	to CU : JaMoPP!CompilationUnit (
		name <- B.entityName,
		classifiers <- thisModule.OperationInterface2Interface(B)
	)
}

unique lazy rule OperationInterface2Interface {
	from O : Palladio!OperationInterface
	to I : JaMoPP!Interface (
		name <- O.entityName,
		typeParameters <- O.signatures__OperationInterface
	)
}

rule Signature2TypeParameter {
	from S :  Palladio!Signature
	to T :  JaMoPP!TypeParameter (
		name <- S.entityName,
		extendTypes <- Set {S.parameters__OperationSignature}
	)
}
--Interface Foo end

--Component Foo
rule BasicComponent2Package {
	from B : Palladio!BasicComponent
	to CU : JaMoPP!Package (
		name <- B.repository__RepositoryComponent.entityName + '.' + B.entityName,
		compilationUnits <- thisModule.BasicComponent2CompilationUnit(B)
	)
}

lazy rule BasicComponent2CompilationUnit {
	from B : Palladio!BasicComponent
	to CU : JaMoPP!CompilationUnit (
		name <- B.entityName + 'Impl',
		classifiers <- thisModule.BasicComponent2Class(B)
	)
}

unique lazy rule BasicComponent2Class {
	from B : Palladio!BasicComponent
	to C : JaMoPP!Class(
		name <- B.entityName + 'Impl',
		implements <- B.providedRoles_InterfaceProvidingEntity,
		members <- B.requiredRoles_InterfaceRequiringEntity->collect(e | thisModule.RequiredRole2Field(e)),
		members <- thisModule.BasicComponent2Constructor(B),
		members <- B.requiredRoles_InterfaceRequiringEntity->collect(e | thisModule.RequiredRole2Getter(e)),
		members <- B.requiredRoles_InterfaceRequiringEntity->collect(e | thisModule.RequiredRole2Setter(e))
	)
}

	--Component Member Foo
lazy rule RequiredRole2Field {
	from R : Palladio!OperationRequiredRole
	to F : JaMoPP!Field(
   		name <- R.entityName,
		typeReference <- thisModule.OperationInterface2ClassifierReference(R.requiredInterface__OperationRequiredRole)
	)
}
	
lazy rule BasicComponent2Constructor {
	from B : Palladio!BasicComponent
	to C : JaMoPP!Constructor (
		name <- B.entityName + 'Constructor',
		parameters <- B.requiredRoles_InterfaceRequiringEntity->collect(e | thisModule.OperationInterface2Parameter(e.requiredInterface__OperationRequiredRole)),
		typeParameters <- B.requiredRoles_InterfaceRequiringEntity->collect(e | e.requiredInterface__OperationRequiredRole.signatures__OperationInterface)
	)
}

		--Member Ref. to Interface
lazy rule OperationInterface2ClassifierReference {
	from I : Palladio!OperationInterface
	to R : JaMoPP!ClassifierReference (
		target <- thisModule.OperationInterface2Interface(I)
	)
}

lazy rule RequiredRole2Getter {
	from R : Palladio!OperationRequiredRole
	to G: JaMoPP!ClassMethod(
		name <- 'get' + R.entityName,
		typeParameters <- R.requiredInterface__OperationRequiredRole.signatures__OperationInterface
	)
}

lazy rule RequiredRole2Setter {
	from R : Palladio!OperationRequiredRole
	to S: JaMoPP!ClassMethod(
		name <- 'set' + R.entityName,
		parameters <- thisModule.OperationInterface2Parameter(R.requiredInterface__OperationRequiredRole)
	)
}

		--Member Ref. to Interface
lazy rule OperationInterface2Parameter {
	from I : Palladio!OperationInterface
	to P : JaMoPP!OrdinaryParameter (
		typeReference <- thisModule.OperationInterface2ClassifierReference(I)
	)
}

rule ProvidedRole2ClassifierReference {
	from P : Palladio!OperationProvidedRole
	to T : JaMoPP!ClassifierReference(
		target <- thisModule.BasicComponent2Class(P.providingEntity_ProvidedRole)
	)
}
	--Component Member Foo end
--Component Foo end

--CompositeDataType Foo
rule CompositeDataType2CompilationUnit {
	from B : Palladio!CompositeDataType
	to CU : JaMoPP!CompilationUnit (
		name <- B.entityName,
		classifiers <- thisModule.CompositeDataType2Class(B)
	)
}

unique lazy rule CompositeDataType2Class { --? wie getter und setter einrichten? TODO
	from D : Palladio!CompositeDataType
	to C : JaMoPP!Class (
		name <- D.entityName,
		members <- D.innerDeclaration_CompositeDataType --Java Class erbt von Member UND MemberContainer
	)	
}

rule InnerDeclaration2Class { --? kaum inhalte in inner declaration, wie soll ich daraus eine sinnvolle klasse machen? TODO
	from I : Palladio!InnerDeclaration
	to C : JaMoPP!Class (
		name <- I.entityName
	)
}

--no CollectionDataType found in MediaStore example
--rule CollectionDataType2Class { --? keine ArrayList in JaMoPP?! (nicht der suchfunktion vertrauen) -MemberContainer-erbe?
--	from D : Palladio!CollectionDataType
--	to C : JaMoPP!Class (
--		
--	)	
--	
--}
